# week07 总结
## MySQL 事务与锁
### MySQL 事务
**事务可靠性模型 ACID:**

* Atomicity：原子性，一次事务要么全成功，要么全失败。
* Consistency:一致性，跨表、跨行、跨事物，数据库始终保持一致性。
* Isolation: 隔离性，事务与事务直接相互隔离，保护事务之间不会被干扰，包含四种隔离级别：
 
| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 读未提交（read-uncommitted） | 是 | 是 | 是 |
| 不可重复读（read-committed） | 否 | 是 | 是 |
| 可重复读（repeatable-read） | 否 | 否 | 是 |
| 串行化（serializable） | 否 | 否 | 否 |

* Durability:, 持久性, 事务提交成功后,不会丢数据。如电源故障, 系统崩溃。

### Mysql 锁
**表级锁**
意向锁: 表明事务稍后要进行哪种类型的锁定
* 共享意向锁(IS): 打算在某些行上设置共享锁 
* 排他意向锁(IX): 打算对某些行设置排他锁 
* Insert 意向锁: Insert 操作设置的间隙锁 
* 自增锁(AUTO-IN) •LOCK TABLES/DDL

**行级锁(InnoDB)**
* 记录锁(Record): 始终锁定索引记录，注意隐藏的聚簇索引;
* 间隙锁(Gap):
* 临键锁(Next-Key): 记录锁+间隙锁的组合; 可“锁定”表中不存在记录
* 谓词锁(Predicat): 空间索引

**死锁**
* 阻塞与互相等待 
* 增删改、锁定读 
* 死锁检测与自动回滚 
* 锁粒度与程序设计

### Mysql日志
**undo log: 撤消日志**
* 保证事务的原子性
* 用处: 事务回滚, 一致性读、崩溃恢复。
* 记录事务回滚时所需的撤消操作
* 一条 INSERT 语句，对应一条 DELETE 的 undo log
* 每个 UPDATE 语句，对应一条相反 UPDATE 的 undo log
* 保存位置:system tablespace (MySQL 5.7默认),undo tablespaces (MySQL 8.0默认)

**redo log: 重做日志**
* 确保事务的持久性，防止事务提交后数据未刷新到磁盘就掉电或崩溃。
* 事务执行过程中写入 redo log,记录事务对数据页做了哪些修改。 
* 提升性能: WAL(Write-Ahead Logging) 技术, 先写日志, 再写磁盘。
* 日志文件: ib_logfile0, ib_logfile1 
* 日志缓冲: innodb_log_buffer_size 
* 强刷: fsync()

### MVCC: 多版本并发控制
* 使 InnoDB 支持一致性读: READ COMMITTED 和 REPEATABLE READ 。 
* 让查询不被阻塞、无需等待被其他事务持有的锁，这种技术手段可以增加并发性能。  * InnoDB 保留被修改行的旧版本。
* 查询正在被其他事务更新的数据时，会读取更新之前的版本。
* 每行数据都存在一个版本号, 每次更新时都更新该版本
* 这种技术在数据库领域的使用并不普遍。某些数据库,以及某些 MySQL 存储引擎都不支持。

**MVCC 实现机制**
* 隐藏列
* 事务链表， 保存还未提交的事务，事务提交则会从链表中摘除
* Read view: 每个 SQL 一个, 包括 rw_trx_ids, low_limit_id, up_limit_id, low_limit_no 等 •回滚段: 通过 undo log 动态构建旧版本数据

## SQL优化
1. 注意数据类型的选择
2. 设计表之前，通读DBA的指导手册/dbaprincaples
3. where条件注意数据类型，避免产生隐式转换（会导致不走索引）
4. 当查询慢时，针对数据量比较大的，对经常查询的条件列加索引
5. 索引类型选B+树，而非hash index
6. 主键使用单调递增
InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。如果主键是递增的，索引则按顺序生成，整个页就很紧凑有序,会近似顺序填满页。
7. 主键长度不要太大
InnoDB一定会有聚集索引，主键索引与记录存储在一起，当主键过长时，每个索引都存这个值，在数据量大的情形下，内存珍贵有限的情况下，mysql有限的缓冲区存储的索引与数据就会减少，磁盘IO的概率就会增加。磁盘IO效率及其低下。
8. 字段选择性-最左原则：
* 某个字段值的重复程序，称为该字段的选择性
9. 修改表结构的危害
* 索引重建
* 锁表
* 抢占资源
* 主从延迟
10. 写入优化
* PreparedStatement 减少 SQL 解析 
* Multiple Values/Add Batch 减少交互 
* Load Data，直接导入
11. 数据更新
范围更新时，注意GAP Lock 的问题，避免导致锁的范围过大
12. 模糊查询
Like的问题: 要前缀匹配（百分号在前），否则不走索引；全文检索尽量用ES/solr
13. 连接查询
* 驱动表的选择问题：小表驱动大表
* 避免笛卡尔积
14. 索引失效
* NULL，not，not in，函数等
* 减少使用 or，可以用 union(注意 union all 的区别)，以及前面提到的like
* 大数据量下，放弃所有条件组合都走索引的幻想，出门左拐“全文检索”
* 必要时可以使用 force index 来强制查询走某个索引
15. 查询 SQL 到底怎么设计?
* 查询数据量和查询次数的平衡
* 避免不必须的大量重复数据传输
* 避免使用临时文件排序或临时表
* 分析类需求，可以用汇总表
16. 实现自增ID方式：
* 数据库自增
* sequence
* 模拟 seq
* UUID
* 时间戳/随机数 
* snowflake
17. 高效分页
* 分页插件都有一个将查询语句作为子查询去count ，会导致性能问题；可以自己去实现count
* 大数量级分页的问题，limit 100000,20：反序取前20
* 技术向:带 id
* 需求向:非精确分页

## MySQL 主从复制
**主从复制核心原理**
1、主库写 binlog
2、从库 relay log

**Binlog 格式**
* ROW
* Statement 
* Mixed

**异步复制:**
传统主从复制，网络或机器故障，会造成数据不一致

**半同步复制**
需要启用插件

**组复制**
基于分布式Paxos协议实现组复制，保证数据一致性

**主从复制的局限性**
1、主从延迟问题 
2、应用侧需要配合读写分离框架 
3、不解决高可用问题

## MySQL 读写分离 
**mycat/ShardingSphere等中间件**

## MySQL 高可用
**高可用的目的**
1、读写分离，提升读的处理能力 
2、故障转移，提供 failover 能力
3、业务侧连接池的心跳重试，实现断线重连，业务不间断，降低 RTO 和 RPO

**高可用定义**
高可用意味着，更少的不可服务时间。一般用SLA/SLO衡量。 1年 = 365天 = 8760小时
99 = 8760 * 1% = 8760 * 0.01 = 87.6小时
99.9 = 8760 * 0.1% = 8760 * 0.001 = 8.76小时
99.99 = 8760 * 0.0001 = 0.876小时 = 0.876 * 60 = 52.6分钟 
99.999 = 8760 * 0.00001 = 0.0876小时 = 0.0876 * 60 = 5.26分钟

**容灾：热备与冷备**
热备表示备用也在提供服务，冷备则反之。
常见的一些策略:
1、多个实例不在一个主机/机架上 
2、跨机房和可用区部署 
3、两地三中心容灾高可用方案

**主从手动切换**
方式1：
1、如果主节点挂掉，将某个从改成主;
2、重新配置其他从节点。
3、修改应用数据源配置
问题：
1、可能数据不一致。
2、需要人工干预。
3、代码和配置的侵入性。

方式2:
1、用 LVS+Keepalived 实现多个节点的探活+请求路由。
2、配置 VIP 或 DNS 实现配置不变更。
问题：
1、手工处理主从切换
2、大量的配置和脚本定义

### MHA
MHA(Master High Availability)目前在 MySQL 高可用方面是一个相对成熟的解决方 案，它由日本 DeNA 公司的 youshimaton(现就职于 Facebook 公司)开发，是一套 优秀的作为 MySQL 高可用性环境下故障切换和主从提升的高可用软件。

基于 Perl 语言开发，一般能在30s内实现主从切换。 切换时，直接通过 SSH 复制主节点的日志。

问题：
1、需要配置 SSH 信息 
2、至少3台

### MGR
如果主节点挂掉，将自动选择某个从改成主;
无需人工干预，基于组复制，保证数据一致性。

问题：
1、外部获得状态变更需要读取数据库。 
2、外部需要使用 LVS/VIP 配置。

**MGR 特点**
1、高一致性：基于分布式Paxos协议实现组复制，保证数据一致性
2、高容错性：自动检测机制，只要不是大多数节点都宕机就可以继续工作，内置防脑裂机制
3、高扩展性：节点的增加和移除会自动更新组成员信息，新节点加入后，自动从其它节点同步增量数据，直到与其它节点一直
4、高灵活性：提供单主模式和多主模式，单主模式在主库宕机后能够自动选主，所有写操作都在主节点进行，多主模式支持多节点写入。

**MGR 适用场景**
* 弹性复制
* 高可用分片

### MySQL Cluster

Mysql InnoDB Cluster 是一个高可用框架，它由以下几部分组成：
1、 MySQL Group Replication: 提供DB到扩展、自动故障转移
2、 MySQL Router: 轻量级中间件，提供应用程序连接目标到故障转移
3、MySQL Shell: 新的MySQL 客户端，多种接口模式。可以设置群组复制及Router

### Orchestrator
Orchestrator 是一款Mysql高可用和复制拓扑管理工具，支持复制拓扑结构调整，自动故障转移和手动主从切换等。

**特点：**
1、自动发现MySQL的复杂拓扑，并在web页面上展示
2、重构复制关系，可以在web进行拖图进行复制关系变更
3、检测主异常，并可以自动或手动恢复，通过Hooks进行自定义脚本
4、支持命令行和web界面管理复制
